use arcis_imports::*;

#[encrypted]
mod circuits {
    use arcis_imports::*;

    /// Private vault configuration - stored encrypted on-chain
    #[derive(Clone, Copy, PartialEq)]
    pub struct PrivateVaultConfig {
        pub version: u8,
        pub destinations: [[u8; 32]; 5],
        pub destination_count: u8,
        pub min_splits: u8,
        pub max_splits: u8,
        pub min_delay_seconds: u32,
        pub max_delay_seconds: u32,
        pub auto_withdraw_enabled: bool,
        pub auto_withdraw_threshold: u64,
        pub owner_pubkey: [u8; 32],
        pub created_at: i64,
        pub updated_at: i64,
        pub use_privacy_cash: bool,
        pub _reserved: [u8; 31],
    }

    /// Result of storing private configuration
    #[derive(Clone, Copy)]
    pub struct ConfigStorageResult {
        pub success: bool,
        pub config_hash: [u8; 32],
        pub stored_at_slot: u64,
    }

    /// Store private vault configuration
    #[instruction]
    pub fn store_private_config(
        config: Enc<Mxe, PrivateVaultConfig>,
        _vault_pubkey: [u8; 32],
        current_slot: u64,
    ) -> Enc<Mxe, ConfigStorageResult> {
        let cfg = config.to_arcis();

        // Validate configuration - simplified
        let is_valid = cfg.destination_count > 0
            && cfg.destination_count <= 5
            && cfg.min_splits > 0
            && cfg.min_splits <= cfg.max_splits
            && cfg.max_splits <= 10;

        // Simple config hash
        let mut config_hash = [0u8; 32];
        config_hash[0] = cfg.version;
        config_hash[1] = cfg.destination_count;
        config_hash[2] = cfg.min_splits;
        config_hash[3] = cfg.max_splits;

        let result = ConfigStorageResult {
            success: is_valid,
            config_hash,
            stored_at_slot: current_slot,
        };

        Mxe::get().from_arcis(result)
    }

    /// A single split within a withdrawal plan
    #[derive(Clone, Copy)]
    pub struct SplitDetail {
        pub destination: [u8; 32],
        pub amount: u64,
        pub delay_seconds: u32,
        pub scheduled_at: i64,
        pub executed_at: i64,
        pub tx_signature: [u8; 64],
    }

    /// Withdrawal execution plan generated by MPC
    #[derive(Clone, Copy)]
    pub struct WithdrawalPlan {
        pub plan_id: [u8; 16],
        pub vault_pubkey: [u8; 32],
        pub total_amount: u64,
        pub split_count: u8,
        pub splits: [SplitDetail; 10],
        pub created_at: i64,
        pub expires_at: i64,
        pub executed_count: u8,
        pub status: u8,
    }

    /// Entropy input for randomization
    pub struct UserEntropy {
        pub user_random: [u8; 32],
    }

    /// Generate a simple withdrawal plan (simplified for testing)
    #[instruction]
    pub fn generate_withdrawal_plan(
        config: Enc<Mxe, PrivateVaultConfig>,
        amount_lamports: u64,
        user_entropy: Enc<Shared, UserEntropy>,
        current_timestamp: u64,
    ) -> Enc<Mxe, WithdrawalPlan> {
        let cfg = config.to_arcis();
        let entropy = user_entropy.to_arcis();

        // Simple 2-split plan for testing
        let num_splits: u8 = 2;
        let base_amount = amount_lamports / 2;
        let remainder = amount_lamports % 2;

        let empty_split = SplitDetail {
            destination: [0u8; 32],
            amount: 0,
            delay_seconds: 0,
            scheduled_at: 0,
            executed_at: 0,
            tx_signature: [0u8; 64],
        };

        let mut splits = [empty_split; 10];

        // First split
        splits[0].destination = cfg.destinations[0];
        splits[0].amount = base_amount;
        splits[0].delay_seconds = cfg.min_delay_seconds;
        splits[0].scheduled_at = (current_timestamp + cfg.min_delay_seconds as u64) as i64;

        // Second split
        let dest_idx = if cfg.destination_count > 1 { 1 } else { 0 };
        splits[1].destination = cfg.destinations[dest_idx];
        splits[1].amount = base_amount + remainder;
        splits[1].delay_seconds = cfg.min_delay_seconds;
        splits[1].scheduled_at = (current_timestamp + 2 * cfg.min_delay_seconds as u64) as i64;

        // Generate plan ID from entropy
        let mut plan_id = [0u8; 16];
        for i in 0..16 {
            plan_id[i] = entropy.user_random[i];
        }

        let plan = WithdrawalPlan {
            plan_id,
            vault_pubkey: cfg.owner_pubkey,
            total_amount: amount_lamports,
            split_count: num_splits,
            splits,
            created_at: current_timestamp as i64,
            expires_at: (current_timestamp + 604800) as i64, // 7 days
            executed_count: 0,
            status: 0, // Pending
        };

        Mxe::get().from_arcis(plan)
    }
}
