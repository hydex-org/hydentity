use anchor_lang::prelude::*;
// TODO: Uncomment when arcium-anchor crate is available
// use arcium_anchor::prelude::*;

use crate::constants::*;
use crate::errors::HydentityError;
use crate::state::{
    EncryptedVaultConfig, NameVault, PendingWithdrawal, WithdrawalRequest,
    WithdrawalStatus, ENCRYPTED_CONFIG_SEED, PENDING_WITHDRAWAL_SEED,
    WITHDRAWAL_REQUEST_SEED,
};

/// Computation definition offset for generate_withdrawal_plan
pub const COMP_DEF_OFFSET_GENERATE_PLAN: u32 = 0; // TODO: Calculate actual value

/// Request a withdrawal with MPC-generated plan
/// 
/// This instruction initiates a withdrawal from the vault. The actual
/// withdrawal plan (destinations, amounts, timing) is generated by the
/// MPC cluster using the user's encrypted configuration.
/// 
/// ## Flow
/// 
/// 1. User provides amount and entropy for randomization
/// 2. Instruction verifies balance and creates withdrawal request
/// 3. Queues Arcium computation to generate plan
/// 4. MPC generates randomized plan from encrypted config
/// 5. Callback creates PendingWithdrawal with encrypted plan
/// 6. MPC executes splits according to plan timing
/// 
/// ## Privacy
/// 
/// - Destinations come from encrypted config (never revealed in request)
/// - Split amounts are randomized within user's configured range
/// - Timing delays are randomized within user's configured range
/// - External observers only see total amount, not split details
pub fn handler(
    ctx: Context<RequestWithdrawal>,
    computation_offset: u64,
    amount: u64,
    user_entropy: [u8; 32],
    entropy_timestamp: i64,
    entropy_signature: [u8; 64],
    arcis_pubkey: [u8; 32],
    encryption_nonce: u128,
) -> Result<()> {
    let vault = &ctx.accounts.vault;
    let config = &ctx.accounts.encrypted_config;
    let request = &mut ctx.accounts.withdrawal_request;
    let clock = Clock::get()?;
    
    // Verify vault owner
    require!(
        vault.owner == ctx.accounts.owner.key(),
        HydentityError::Unauthorized
    );
    
    // Verify config is initialized
    require!(
        config.is_initialized,
        HydentityError::ConfigNotInitialized
    );
    
    // Verify sufficient balance
    // Note: In production, get actual vault balance from vault authority account
    // For now, we trust the frontend to check balance before requesting
    require!(amount > 0, HydentityError::InvalidAmount);
    
    // Verify no pending withdrawal for this vault
    // (Can only have one active withdrawal at a time)
    // This is checked by the PDA derivation - if account exists, it will fail init
    
    // Initialize withdrawal request
    request.vault = vault.key();
    request.amount = amount;
    request.user_entropy = user_entropy;
    request.entropy_timestamp = entropy_timestamp;
    request.entropy_signature = entropy_signature;
    request.requested_at = clock.unix_timestamp;
    request.computation_offset = computation_offset;
    request.plan_generated = false;
    request.bump = ctx.bumps.withdrawal_request;
    
    // TODO: Queue Arcium computation when arcium-anchor is available
    // The computation will:
    // 1. Load encrypted config for this vault
    // 2. Decrypt config using MPC
    // 3. Generate randomized withdrawal plan
    // 4. Return encrypted plan via callback
    //
    // Example (uncomment when arcium-anchor available):
    // ```
    // let args = vec![
    //     // Reference to encrypted config account
    //     Argument::AccountRef(config.key().to_bytes().to_vec()),
    //     // Withdrawal amount
    //     Argument::PlaintextU64(amount),
    //     // User entropy (encrypted)
    //     Argument::ArcisPubkey(arcis_pubkey),
    //     Argument::PlaintextU128(encryption_nonce),
    //     Argument::EncryptedBytes(user_entropy.to_vec()),
    //     // Current timestamp
    //     Argument::PlaintextI64(clock.unix_timestamp),
    // ];
    //
    // ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;
    //
    // queue_computation(
    //     ctx.accounts,
    //     computation_offset,
    //     args,
    //     None, // No callback server needed
    //     vec![GenerateWithdrawalPlanCallback::callback_ix(&[
    //         CallbackAccount {
    //             pubkey: request.key(),
    //             is_writable: true,
    //         },
    //         CallbackAccount {
    //             pubkey: ctx.accounts.pending_withdrawal.key(),
    //             is_writable: true,
    //         },
    //     ])],
    //     1,
    // )?;
    // ```
    
    msg!("Withdrawal requested from vault: {}", vault.key());
    msg!("Amount: {} lamports", amount);
    msg!("Awaiting MPC plan generation (computation_offset: {})", computation_offset);
    
    Ok(())
}

/// Accounts for requesting a withdrawal
#[derive(Accounts)]
#[instruction(computation_offset: u64, amount: u64)]
pub struct RequestWithdrawal<'info> {
    /// Vault owner (must sign)
    #[account(mut)]
    pub owner: Signer<'info>,
    
    /// The vault to withdraw from
    #[account(
        seeds = [VAULT_SEED, vault.sns_name_account.as_ref()],
        bump = vault.bump,
        constraint = vault.owner == owner.key() @ HydentityError::Unauthorized,
    )]
    pub vault: Account<'info, NameVault>,
    
    /// Encrypted configuration (must exist)
    #[account(
        seeds = [ENCRYPTED_CONFIG_SEED, vault.key().as_ref()],
        bump = encrypted_config.bump,
        constraint = encrypted_config.is_initialized @ HydentityError::ConfigNotInitialized,
    )]
    pub encrypted_config: Account<'info, EncryptedVaultConfig>,
    
    /// Withdrawal request account (created)
    #[account(
        init,
        payer = owner,
        space = WithdrawalRequest::SPACE,
        seeds = [WITHDRAWAL_REQUEST_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub withdrawal_request: Account<'info, WithdrawalRequest>,
    
    /// Pending withdrawal account (created by callback)
    /// We need to pass this so callback can initialize it
    /// CHECK: Initialized by callback
    #[account(
        mut,
        seeds = [PENDING_WITHDRAWAL_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub pending_withdrawal: UncheckedAccount<'info>,
    
    // ===== Arcium Accounts (TODO: uncomment when arcium-anchor available) =====
    // (Same as in store_private_config.rs)
    
    pub system_program: Program<'info, System>,
}

// ===== Callback Handler (TODO: uncomment when arcium-anchor available) =====
//
// /// Callback from Arcium after MPC generates withdrawal plan
// #[arcium_callback(encrypted_ix = "generate_withdrawal_plan")]
// pub fn generate_withdrawal_plan_callback(
//     ctx: Context<GenerateWithdrawalPlanCallback>,
//     output: ComputationOutputs<GenerateWithdrawalPlanOutput>,
// ) -> Result<()> {
//     let result = match output {
//         ComputationOutputs::Success(GenerateWithdrawalPlanOutput { field_0 }) => field_0,
//         _ => return Err(HydentityError::ComputationFailed.into()),
//     };
//     
//     let request = &mut ctx.accounts.withdrawal_request;
//     let pending = &mut ctx.accounts.pending_withdrawal;
//     let clock = Clock::get()?;
//     
//     // Mark request as processed
//     request.plan_generated = true;
//     
//     // The result contains the encrypted withdrawal plan
//     // Parse plan metadata from result
//     let plan_id: [u8; 16] = result.ciphertexts[0][0..16].try_into().unwrap();
//     let total_splits = result.ciphertexts[0][16];
//     let expires_at = i64::from_le_bytes(result.ciphertexts[0][17..25].try_into().unwrap());
//     
//     // Initialize pending withdrawal with encrypted plan
//     pending.initialize(
//         request.vault,
//         result.ciphertexts[0].try_into().unwrap_or([0u8; 1024]),
//         result.nonce.to_le_bytes()[0..16].try_into().unwrap(),
//         plan_id,
//         total_splits,
//         request.amount,
//         clock.unix_timestamp,
//         expires_at,
//         request.computation_offset,
//         ctx.bumps.pending_withdrawal,
//     );
//     
//     msg!("Withdrawal plan generated");
//     msg!("Plan ID: {:?}", plan_id);
//     msg!("Total splits: {}", total_splits);
//     msg!("Expires at: {}", expires_at);
//     
//     Ok(())
// }
//
// #[callback_accounts("generate_withdrawal_plan")]
// #[derive(Accounts)]
// pub struct GenerateWithdrawalPlanCallback<'info> {
//     pub arcium_program: Program<'info, Arcium>,
//     
//     #[account(address = derive_comp_def_pda!(COMP_DEF_OFFSET_GENERATE_PLAN))]
//     pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
//     
//     #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
//     pub instructions_sysvar: AccountInfo<'info>,
//     
//     #[account(mut)]
//     pub withdrawal_request: Account<'info, WithdrawalRequest>,
//     
//     #[account(mut)]
//     pub pending_withdrawal: Account<'info, PendingWithdrawal>,
// }

/// Execute a single split from a pending withdrawal
/// 
/// This instruction is called by the MPC cluster when it's time to
/// execute a split. The MPC decrypts the plan, verifies timing,
/// and signs the transfer transaction.
/// 
/// ## Flow
/// 
/// 1. MPC monitors pending withdrawals for due splits
/// 2. When a split is due, MPC queues this computation
/// 3. MPC decrypts destination and amount for this split
/// 4. MPC signs transfer transaction
/// 5. Transfer is broadcast to Solana
/// 6. Callback updates split status
pub fn execute_split_handler(
    ctx: Context<ExecuteSplit>,
    computation_offset: u64,
    split_index: u8,
) -> Result<()> {
    let pending = &ctx.accounts.pending_withdrawal;
    let clock = Clock::get()?;
    
    // Verify withdrawal is active
    require!(
        pending.is_active(),
        HydentityError::WithdrawalNotActive
    );
    
    // Verify not expired
    require!(
        !pending.is_expired(clock.unix_timestamp),
        HydentityError::WithdrawalExpired
    );
    
    // Verify split index is valid
    require!(
        split_index < pending.total_splits,
        HydentityError::InvalidSplitIndex
    );
    
    // TODO: Queue Arcium computation when arcium-anchor is available
    // The computation will:
    // 1. Decrypt the withdrawal plan
    // 2. Get the split details (destination, amount)
    // 3. Verify it's time to execute
    // 4. Sign the transfer transaction
    // 5. Return transfer details via callback
    
    msg!("Executing split {} of {}", split_index + 1, pending.total_splits);
    
    Ok(())
}

/// Accounts for executing a withdrawal split
#[derive(Accounts)]
#[instruction(computation_offset: u64, split_index: u8)]
pub struct ExecuteSplit<'info> {
    /// Can be called by anyone (MPC nodes), but authorization is in the plan
    #[account(mut)]
    pub payer: Signer<'info>,
    
    /// The pending withdrawal
    #[account(
        mut,
        seeds = [PENDING_WITHDRAWAL_SEED, pending_withdrawal.vault.as_ref(), &pending_withdrawal.computation_offset.to_le_bytes()],
        bump = pending_withdrawal.bump,
        constraint = pending_withdrawal.is_active() @ HydentityError::WithdrawalNotActive,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
    
    // ===== Arcium Accounts (TODO: uncomment when arcium-anchor available) =====
    
    pub system_program: Program<'info, System>,
}

/// Cancel a pending withdrawal
/// 
/// Allows the vault owner to cancel a withdrawal before it completes.
/// Any unexecuted splits will not be processed.
pub fn cancel_withdrawal_handler(
    ctx: Context<CancelWithdrawal>,
) -> Result<()> {
    let pending = &mut ctx.accounts.pending_withdrawal;
    
    // Verify withdrawal is still active
    require!(
        pending.is_active(),
        HydentityError::WithdrawalNotActive
    );
    
    // Cancel the withdrawal
    pending.cancel();
    
    msg!("Withdrawal cancelled");
    msg!("Completed {} of {} splits before cancellation", 
        pending.completed_splits, pending.total_splits);
    
    Ok(())
}

/// Accounts for cancelling a withdrawal
#[derive(Accounts)]
pub struct CancelWithdrawal<'info> {
    /// Vault owner (must sign)
    #[account(mut)]
    pub owner: Signer<'info>,
    
    /// The vault
    #[account(
        seeds = [VAULT_SEED, vault.sns_name_account.as_ref()],
        bump = vault.bump,
        constraint = vault.owner == owner.key() @ HydentityError::Unauthorized,
    )]
    pub vault: Account<'info, NameVault>,
    
    /// The pending withdrawal to cancel
    #[account(
        mut,
        seeds = [PENDING_WITHDRAWAL_SEED, vault.key().as_ref(), &pending_withdrawal.computation_offset.to_le_bytes()],
        bump = pending_withdrawal.bump,
        constraint = pending_withdrawal.vault == vault.key() @ HydentityError::InvalidVault,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
}

