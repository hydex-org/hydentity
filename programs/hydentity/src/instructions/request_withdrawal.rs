use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use arcium_client::idl::arcium::types::CallbackAccount;

use crate::constants::*;
use crate::errors::HydentityError;
use crate::state::{
    EncryptedVaultConfig, NameVault, PendingWithdrawal, WithdrawalRequest,
    ENCRYPTED_CONFIG_SEED, PENDING_WITHDRAWAL_SEED, WITHDRAWAL_REQUEST_SEED,
};
use crate::events::{WithdrawalRequested, WithdrawalPlanGenerated};

/// Computation definition offset for generate_withdrawal_plan
const COMP_DEF_OFFSET_GENERATE_PLAN: u32 = comp_def_offset!("generate_withdrawal_plan");

/// Offset of encrypted_data field in EncryptedVaultConfig
/// discriminator (8) + vault (32) = 40
const ENCRYPTED_CONFIG_DATA_OFFSET: u32 = 40;
const ENCRYPTED_CONFIG_DATA_SIZE: u32 = 512;

/// Request a withdrawal with MPC-generated plan
/// 
/// This instruction initiates a withdrawal from the vault. The actual
/// withdrawal plan (destinations, amounts, timing) is generated by the
/// MPC cluster using the user's encrypted configuration.
/// 
/// ## Flow
/// 
/// 1. User provides amount and entropy for randomization
/// 2. Instruction verifies balance and creates withdrawal request
/// 3. Queues Arcium computation to generate plan
/// 4. MPC generates randomized plan from encrypted config
/// 5. Callback creates PendingWithdrawal with encrypted plan
/// 6. MPC executes splits according to plan timing
/// 
/// ## Privacy
/// 
/// - Destinations come from encrypted config (never revealed in request)
/// - Split amounts are randomized within user's configured range
/// - Timing delays are randomized within user's configured range
/// - External observers only see total amount, not split details
pub fn handler(
    ctx: Context<RequestWithdrawal>,
    computation_offset: u64,
    amount: u64,
    user_entropy: [u8; 32],
    entropy_timestamp: i64,
    entropy_signature: [u8; 64],
    arcis_pubkey: [u8; 32],
    encryption_nonce: u128,
) -> Result<()> {
    let vault = &ctx.accounts.vault;
    let config = &ctx.accounts.encrypted_config;
    let request = &mut ctx.accounts.withdrawal_request;
    let clock = Clock::get()?;
    
    // Verify vault owner
    require!(
        vault.owner == ctx.accounts.owner.key(),
        HydentityError::Unauthorized
    );
    
    // Verify config is initialized
    require!(
        config.is_initialized,
        HydentityError::ConfigNotInitialized
    );
    
    // Verify sufficient balance
    // Note: In production, get actual vault balance from vault authority account
    // For now, we trust the frontend to check balance before requesting
    require!(amount > 0, HydentityError::InvalidAmount);
    
    // Initialize withdrawal request
    request.vault = vault.key();
    request.amount = amount;
    request.user_entropy = user_entropy;
    request.entropy_timestamp = entropy_timestamp;
    request.entropy_signature = entropy_signature;
    request.requested_at = clock.unix_timestamp;
    request.computation_offset = computation_offset;
    request.plan_generated = false;
    request.bump = ctx.bumps.withdrawal_request;
    
    // Initialize pending withdrawal with placeholder data
    // The callback will update it with the actual encrypted plan
    let pending = &mut ctx.accounts.pending_withdrawal;
    pending.initialize(
        vault.key(),
        [0u8; 1024], // Placeholder - will be updated in callback
        [0u8; 16],   // Placeholder - will be updated in callback
        computation_offset.to_le_bytes()[0..16].try_into().unwrap_or([0u8; 16]),
        0,           // Placeholder - will be updated in callback
        amount,
        clock.unix_timestamp,
        clock.unix_timestamp + (7 * 24 * 60 * 60), // 7 days placeholder
        computation_offset,
        ctx.bumps.pending_withdrawal,
    );
    
    // Build arguments for Arcium computation
    // The encrypted instruction expects:
    // - vault_config: Enc<Mxe, &PrivateVaultConfig> (from encrypted_config account)
    // - amount_lamports: u64
    // - user_entropy: Enc<Shared, UserEntropy>
    // - current_timestamp: i64
    ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;
    
    let args = ArgBuilder::new()
        .account(
            config.key(),
            ENCRYPTED_CONFIG_DATA_OFFSET,
            ENCRYPTED_CONFIG_DATA_SIZE,
        )
        .plaintext_u64(amount)
        .x25519_pubkey(arcis_pubkey)
        .plaintext_u128(encryption_nonce)
        .encrypted_u8(user_entropy)
        .plaintext_i64(clock.unix_timestamp)
        .build();
    
    // Queue Arcium computation
    queue_computation(
        ctx.accounts,
        computation_offset,
        args,
        None,
        vec![GenerateWithdrawalPlanCallback::callback_ix(
            computation_offset,
            &ctx.accounts.mxe_account,
            &[
                CallbackAccount {
                    pubkey: request.key(),
                    is_writable: true,
                },
                CallbackAccount {
                    pubkey: ctx.accounts.pending_withdrawal.key(),
                    is_writable: true,
                },
            ],
        )?],
        1,
        0,
    )?;
    
    msg!("Withdrawal requested from vault: {}", vault.key());
    msg!("Amount: {} lamports", amount);
    msg!("Computation offset: {}", computation_offset);
    
    emit!(WithdrawalRequested {
        vault: vault.key(),
        amount,
        computation_offset,
        timestamp: clock.unix_timestamp,
    });
    
    Ok(())
}

/// Accounts for requesting a withdrawal
#[queue_computation_accounts("generate_withdrawal_plan", owner)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, amount: u64)]
pub struct RequestWithdrawal<'info> {
    /// Vault owner (must sign)
    #[account(mut)]
    pub owner: Signer<'info>,
    
    /// The vault to withdraw from
    #[account(
        seeds = [VAULT_SEED, vault.sns_name.as_ref()],
        bump = vault.bump,
        constraint = vault.owner == owner.key() @ HydentityError::Unauthorized,
    )]
    pub vault: Account<'info, NameVault>,
    
    /// Encrypted configuration (must exist)
    #[account(
        seeds = [ENCRYPTED_CONFIG_SEED, vault.key().as_ref()],
        bump = encrypted_config.bump,
        constraint = encrypted_config.is_initialized @ HydentityError::ConfigNotInitialized,
    )]
    pub encrypted_config: Account<'info, EncryptedVaultConfig>,
    
    /// Withdrawal request account (created)
    #[account(
        init,
        payer = owner,
        space = WithdrawalRequest::SPACE,
        seeds = [WITHDRAWAL_REQUEST_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub withdrawal_request: Account<'info, WithdrawalRequest>,
    
    /// Pending withdrawal account (initialized here, updated by callback)
    #[account(
        init,
        payer = owner,
        space = PendingWithdrawal::SPACE,
        seeds = [PENDING_WITHDRAWAL_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
    
    // Arcium accounts
    #[account(
        init_if_needed,
        space = 9,
        payer = owner,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    
    #[account(address = derive_mxe_pda!())]
    pub mxe_account: Account<'info, MXEAccount>,
    
    #[account(
        mut,
        address = derive_mempool_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    
    #[account(
        mut,
        address = derive_execpool_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset, mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: computation_account, checked by the arcium program
    pub computation_account: UncheckedAccount<'info>,
    
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_GENERATE_PLAN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    pub cluster_account: Account<'info, Cluster>,
    
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
}

/// Callback from Arcium after MPC generates withdrawal plan
#[arcium_callback(encrypted_ix = "generate_withdrawal_plan")]
pub fn generate_withdrawal_plan_callback(
    ctx: Context<GenerateWithdrawalPlanCallback>,
    output: SignedComputationOutputs<WithdrawalPlanOutput>,
) -> Result<()> {
    let result = match output.verify_output(
        &ctx.accounts.cluster_account,
        &ctx.accounts.computation_account,
    ) {
        Ok(WithdrawalPlanOutput { field_0 }) => field_0,
        Err(_) => return Err(HydentityError::InvalidMpcResult.into()),
    };
    
    let request = &mut ctx.accounts.withdrawal_request;
    let pending = &mut ctx.accounts.pending_withdrawal;
    let clock = Clock::get()?;
    
    // Mark request as processed
    request.plan_generated = true;
    
    // Extract encrypted plan data from result
    // The result contains Enc<Mxe, WithdrawalPlan>, which is encrypted bytes + nonce
    // We need to store the encrypted bytes and extract metadata
    // Note: The actual structure will be auto-generated by Arcium
    // For now, assuming result contains:
    // - field_0.ciphertexts: encrypted plan bytes (need to concatenate if multiple)
    // - field_0.nonce: encryption nonce
    
    // The plan is encrypted, so we store the encrypted bytes as-is
    // We'll need metadata (plan_id, total_splits, expires_at) but these are inside the encrypted plan
    // For MVP, we'll use placeholder values and rely on the encrypted data
    // TODO: Consider returning metadata separately or having a metadata struct
    
    // Extract nonce (assuming it's 16 bytes)
    let nonce = result.nonce.to_le_bytes();
    let nonce_bytes: [u8; 16] = nonce[0..16].try_into().unwrap_or([0u8; 16]);
    
    // Extract encrypted plan bytes
    // Assuming result.ciphertexts is a Vec<[u8; 32]> or similar
    // We need to concatenate to fit in [u8; 1024]
    let mut encrypted_plan = [0u8; 1024];
    let ciphertexts = &result.ciphertexts;
    let mut offset = 0;
    for ciphertext in ciphertexts.iter().take(32) {  // 32 * 32 = 1024 bytes
        if offset + 32 <= 1024 {
            encrypted_plan[offset..offset + 32].copy_from_slice(ciphertext);
            offset += 32;
        }
    }
    
    // Use placeholder values for metadata
    // These should ideally be extracted from the decrypted plan
    // but for MVP we'll generate them from the computation offset
    let computation_offset = request.computation_offset;
    let plan_id_bytes = computation_offset.to_le_bytes();
    let mut plan_id = [0u8; 16];
    plan_id[0..8].copy_from_slice(&plan_id_bytes);
    
    // Default values (should be extracted from plan in production)
    // TODO: Extract metadata from decrypted plan when available
    let total_splits = 2u8;  // Placeholder
    let expires_at = clock.unix_timestamp + (7 * 24 * 60 * 60); // 7 days from now
    
    // Update pending withdrawal with encrypted plan data
    let pending = &mut ctx.accounts.pending_withdrawal;
    
    // Verify this pending withdrawal matches the request
    require!(
        pending.vault == request.vault && pending.computation_offset == request.computation_offset,
        HydentityError::InvalidVault
    );
    
    // Update with encrypted plan data
    pending.encrypted_plan = encrypted_plan;
    pending.nonce = nonce_bytes;
    // Note: plan_id, total_splits, and expires_at are already set (placeholders)
    // In production, these should be extracted from the decrypted plan
    // For MVP, using placeholder values
    
    msg!("Withdrawal plan generated");
    msg!("Plan ID: {:?}", plan_id);
    msg!("Total splits: {}", total_splits);
    
    emit!(WithdrawalPlanGenerated {
        vault: request.vault,
        plan_id,
        total_splits,
        timestamp: clock.unix_timestamp,
    });
    
    Ok(())
}

#[callback_accounts("generate_withdrawal_plan")]
#[derive(Accounts)]
pub struct GenerateWithdrawalPlanCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_GENERATE_PLAN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    
    #[account(address = derive_mxe_pda!())]
    pub mxe_account: Account<'info, MXEAccount>,
    
    /// CHECK: computation_account, checked by arcium program via constraints in the callback context
    pub computation_account: UncheckedAccount<'info>,
    
    #[account(
        address = derive_cluster_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    pub cluster_account: Account<'info, Cluster>,
    
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    
    #[account(mut)]
    pub withdrawal_request: Account<'info, WithdrawalRequest>,
    
    #[account(
        mut,
        seeds = [PENDING_WITHDRAWAL_SEED, withdrawal_request.vault.as_ref(), &withdrawal_request.computation_offset.to_le_bytes()],
        bump = pending_withdrawal.bump,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
}

pub fn init_generate_plan_comp_def(
    ctx: Context<InitGeneratePlanCompDef>,
) -> Result<()> {
    init_comp_def(ctx.accounts, None, None)?;
    Ok(())
}

#[init_computation_definition_accounts("generate_withdrawal_plan", payer)]
#[derive(Accounts)]
pub struct InitGeneratePlanCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program
    pub comp_def_account: UncheckedAccount<'info>,
    
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}

// Placeholder for the auto-generated output type
// This will be generated by Arcium from the encrypted-ixs/generate_plan.rs return type
// The actual structure will match SignedComputationOutputs<Enc<Mxe, WithdrawalPlan>>
// For now, using a placeholder structure that matches the expected output format
pub struct WithdrawalPlanOutput {
    // The actual structure will be auto-generated by Arcium
    // This placeholder matches the pattern from Arcium examples
    pub field_0: WithdrawalPlanResultRaw,
}

// Placeholder for the result type structure
// This will be replaced by Arcium-generated types
// The actual type will represent the encrypted WithdrawalPlan output
pub struct WithdrawalPlanResultRaw {
    pub ciphertexts: Vec<[u8; 32]>,
    pub nonce: u128,
}
