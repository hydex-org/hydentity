use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
use arcium_client::idl::arcium::types::CallbackAccount;

use crate::constants::*;
use crate::errors::HydentityError;
use crate::{ID, ID_CONST, SignerAccount, validate_callback_ixs}; // Required for Arcium macros

/// Local error code for Arcium macros (must be in scope for macro expansion)
#[error_code]
pub enum ErrorCode {
    #[msg("The cluster is not set")]
    ClusterNotSet,
}
use crate::state::{
    EncryptedVaultConfig, NameVault, PendingWithdrawal, WithdrawalRequest,
    ENCRYPTED_CONFIG_SEED, PENDING_WITHDRAWAL_SEED, WITHDRAWAL_REQUEST_SEED,
};
use crate::events::{WithdrawalRequested, WithdrawalPlanGenerated};

/// Computation definition offset for generate_withdrawal_plan
/// Using offset 2 (fixed) - must match the uploadCircuit SDK offset
pub const COMP_DEF_OFFSET_GENERATE_PLAN: u32 = 2;

/// Offset of encrypted_data field in EncryptedVaultConfig
/// discriminator (8) + vault (32) = 40
const ENCRYPTED_CONFIG_DATA_OFFSET: u32 = 40;
const ENCRYPTED_CONFIG_DATA_SIZE: u32 = 512;

/// Request a withdrawal with MPC-generated plan
/// 
/// This instruction initiates a withdrawal from the vault. The actual
/// withdrawal plan (destinations, amounts, timing) is generated by the
/// MPC cluster using the user's encrypted configuration.
/// 
/// ## Flow
/// 
/// 1. User provides amount and entropy for randomization
/// 2. Instruction verifies balance and creates withdrawal request
/// 3. Queues Arcium computation to generate plan
/// 4. MPC generates randomized plan from encrypted config
/// 5. Callback creates PendingWithdrawal with encrypted plan
/// 6. MPC executes splits according to plan timing
/// 
/// ## Privacy
/// 
/// - Destinations come from encrypted config (never revealed in request)
/// - Split amounts are randomized within user's configured range
/// - Timing delays are randomized within user's configured range
/// - External observers only see total amount, not split details
pub fn handler(
    ctx: Context<RequestWithdrawal>,
    computation_offset: u64,
    amount: u64,
    user_entropy: [u8; 32],
    entropy_timestamp: i64,
    entropy_signature: [u8; 64],
    arcis_pubkey: [u8; 32],
    encryption_nonce: u128,
) -> Result<()> {
    let clock = Clock::get()?;

    // Capture keys before mutable borrows
    let vault_key = ctx.accounts.vault.key();
    let config_key = ctx.accounts.encrypted_config.key();
    let request_key = ctx.accounts.withdrawal_request.key();
    let pending_key = ctx.accounts.pending_withdrawal.key();

    // Verify vault owner
    require!(
        ctx.accounts.vault.owner == ctx.accounts.owner.key(),
        HydentityError::Unauthorized
    );

    // Verify config is initialized
    require!(
        ctx.accounts.encrypted_config.is_initialized,
        HydentityError::ConfigNotInitialized
    );

    // Verify sufficient balance
    require!(amount > 0, HydentityError::InvalidAmount);

    // Initialize withdrawal request
    {
        let request = &mut ctx.accounts.withdrawal_request;
        request.vault = vault_key;
        request.amount = amount;
        request.user_entropy = user_entropy;
        request.entropy_timestamp = entropy_timestamp;
        request.entropy_signature = entropy_signature;
        request.requested_at = clock.unix_timestamp;
        request.computation_offset = computation_offset;
        request.plan_generated = false;
        request.bump = ctx.bumps.withdrawal_request;
    }

    // Initialize pending withdrawal with placeholder data
    {
        let pending = &mut ctx.accounts.pending_withdrawal;
        pending.initialize(
            vault_key,
            [0u8; 1024], // Placeholder - will be updated in callback
            [0u8; 16],   // Placeholder - will be updated in callback
            computation_offset.to_le_bytes()[0..16].try_into().unwrap_or([0u8; 16]),
            0,           // Placeholder - will be updated in callback
            amount,
            clock.unix_timestamp,
            clock.unix_timestamp + (7 * 24 * 60 * 60), // 7 days placeholder
            computation_offset,
            ctx.bumps.pending_withdrawal,
        );
    }

    // Set up Arcium signer
    ctx.accounts.sign_pda_account.bump = ctx.bumps.sign_pda_account;

    // Build arguments for Arcium computation
    let args = ArgBuilder::new()
        .account(
            config_key,
            ENCRYPTED_CONFIG_DATA_OFFSET,
            ENCRYPTED_CONFIG_DATA_SIZE,
        )
        .plaintext_u64(amount)
        .x25519_pubkey(arcis_pubkey)
        .plaintext_u128(encryption_nonce)
        .encrypted_u8(user_entropy)
        .plaintext_u64(clock.unix_timestamp as u64)
        .build();

    // Queue Arcium computation
    queue_computation(
        ctx.accounts,
        computation_offset,
        args,
        None,
        vec![GenerateWithdrawalPlanCallback::callback_ix(
            computation_offset,
            &ctx.accounts.mxe_account,
            &[
                CallbackAccount {
                    pubkey: request_key,
                    is_writable: true,
                },
                CallbackAccount {
                    pubkey: pending_key,
                    is_writable: true,
                },
            ],
        )?],
        1,
        0,
    )?;
    
    msg!("Withdrawal requested from vault: {}", vault_key);
    msg!("Amount: {} lamports", amount);
    msg!("Computation offset: {}", computation_offset);

    emit!(WithdrawalRequested {
        vault: vault_key,
        amount,
        computation_offset,
        timestamp: clock.unix_timestamp,
    });
    
    Ok(())
}

/// Accounts for requesting a withdrawal
#[queue_computation_accounts("generate_withdrawal_plan", owner)]
#[derive(Accounts)]
#[instruction(computation_offset: u64, amount: u64)]
pub struct RequestWithdrawal<'info> {
    /// Vault owner (must sign)
    #[account(mut)]
    pub owner: Signer<'info>,
    
    /// The vault to withdraw from
    #[account(
        seeds = [VAULT_SEED, vault.sns_name.as_ref()],
        bump = vault.bump,
        constraint = vault.owner == owner.key() @ HydentityError::Unauthorized,
    )]
    pub vault: Account<'info, NameVault>,
    
    /// Encrypted configuration (must exist)
    #[account(
        seeds = [ENCRYPTED_CONFIG_SEED, vault.key().as_ref()],
        bump = encrypted_config.bump,
        constraint = encrypted_config.is_initialized @ HydentityError::ConfigNotInitialized,
    )]
    pub encrypted_config: Account<'info, EncryptedVaultConfig>,
    
    /// Withdrawal request account (created)
    #[account(
        init,
        payer = owner,
        space = WithdrawalRequest::SPACE,
        seeds = [WITHDRAWAL_REQUEST_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub withdrawal_request: Account<'info, WithdrawalRequest>,
    
    /// Pending withdrawal account (initialized here, updated by callback)
    #[account(
        init,
        payer = owner,
        space = PendingWithdrawal::SPACE,
        seeds = [PENDING_WITHDRAWAL_SEED, vault.key().as_ref(), &computation_offset.to_le_bytes()],
        bump,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
    
    // Arcium accounts
    #[account(
        init_if_needed,
        space = 9,
        payer = owner,
        seeds = [&SIGN_PDA_SEED],
        bump,
        address = derive_sign_pda!(),
    )]
    pub sign_pda_account: Account<'info, SignerAccount>,
    
    #[account(address = derive_mxe_pda!())]
    pub mxe_account: Account<'info, MXEAccount>,
    
    #[account(
        mut,
        address = derive_mempool_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: mempool_account, checked by the arcium program
    pub mempool_account: UncheckedAccount<'info>,
    
    #[account(
        mut,
        address = derive_execpool_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: executing_pool, checked by the arcium program
    pub executing_pool: UncheckedAccount<'info>,
    
    #[account(
        mut,
        address = derive_comp_pda!(computation_offset, mxe_account, HydentityError::ComputationFailed)
    )]
    /// CHECK: computation_account, checked by the arcium program
    pub computation_account: UncheckedAccount<'info>,
    
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_GENERATE_PLAN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    
    #[account(
        mut,
        address = derive_cluster_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    pub cluster_account: Account<'info, Cluster>,
    
    #[account(
        mut,
        address = ARCIUM_FEE_POOL_ACCOUNT_ADDRESS,
    )]
    pub pool_account: Account<'info, FeePool>,
    
    #[account(
        address = ARCIUM_CLOCK_ACCOUNT_ADDRESS,
    )]
    pub clock_account: Account<'info, ClockAccount>,
    
    pub system_program: Program<'info, System>,
    pub arcium_program: Program<'info, Arcium>,
}

/// Callback from Arcium after MPC generates withdrawal plan
#[arcium_callback(encrypted_ix = "generate_withdrawal_plan")]
pub fn generate_withdrawal_plan_callback(
    ctx: Context<GenerateWithdrawalPlanCallback>,
    output: SignedComputationOutputs<GenerateWithdrawalPlanOutput>,
) -> Result<()> {
    // Verify the computation output
    let _result = match output.verify_output(
        &ctx.accounts.cluster_account,
        &ctx.accounts.computation_account,
    ) {
        Ok(result) => result,
        Err(_) => return Err(HydentityError::InvalidMpcResult.into()),
    };

    let request = &mut ctx.accounts.withdrawal_request;
    let pending = &mut ctx.accounts.pending_withdrawal;
    let clock = Clock::get()?;

    // Mark request as processed
    request.plan_generated = true;

    // Verify this pending withdrawal matches the request
    require!(
        pending.vault == request.vault && pending.computation_offset == request.computation_offset,
        HydentityError::InvalidVault
    );

    // Generate plan_id from computation offset
    let computation_offset = request.computation_offset;
    let plan_id_bytes = computation_offset.to_le_bytes();
    let mut plan_id = [0u8; 16];
    plan_id[0..8].copy_from_slice(&plan_id_bytes);

    // Placeholder values for now - the actual encrypted plan is in the MPC output
    let total_splits = 2u8;

    msg!("Withdrawal plan generated");
    msg!("Plan ID: {:?}", plan_id);
    msg!("Total splits: {}", total_splits);

    emit!(WithdrawalPlanGenerated {
        vault: request.vault,
        plan_id,
        total_splits,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

#[callback_accounts("generate_withdrawal_plan")]
#[derive(Accounts)]
pub struct GenerateWithdrawalPlanCallback<'info> {
    pub arcium_program: Program<'info, Arcium>,
    
    #[account(
        address = derive_comp_def_pda!(COMP_DEF_OFFSET_GENERATE_PLAN)
    )]
    pub comp_def_account: Account<'info, ComputationDefinitionAccount>,
    
    #[account(address = derive_mxe_pda!())]
    pub mxe_account: Account<'info, MXEAccount>,
    
    /// CHECK: computation_account, checked by arcium program via constraints in the callback context
    pub computation_account: UncheckedAccount<'info>,
    
    #[account(
        address = derive_cluster_pda!(mxe_account, HydentityError::ComputationFailed)
    )]
    pub cluster_account: Account<'info, Cluster>,
    
    #[account(address = ::anchor_lang::solana_program::sysvar::instructions::ID)]
    /// CHECK: instructions_sysvar, checked by the account constraint
    pub instructions_sysvar: AccountInfo<'info>,
    
    #[account(mut)]
    pub withdrawal_request: Account<'info, WithdrawalRequest>,
    
    #[account(
        mut,
        seeds = [PENDING_WITHDRAWAL_SEED, withdrawal_request.vault.as_ref(), &withdrawal_request.computation_offset.to_le_bytes()],
        bump = pending_withdrawal.bump,
    )]
    pub pending_withdrawal: Account<'info, PendingWithdrawal>,
}

pub fn init_generate_plan_comp_def(
    ctx: Context<InitGeneratePlanCompDef>,
) -> Result<()> {
    init_comp_def(ctx.accounts, None, None)?;
    Ok(())
}

#[init_computation_definition_accounts("generate_withdrawal_plan", payer)]
#[derive(Accounts)]
pub struct InitGeneratePlanCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    
    #[account(
        mut,
        address = derive_mxe_pda!()
    )]
    pub mxe_account: Box<Account<'info, MXEAccount>>,
    
    #[account(mut)]
    /// CHECK: comp_def_account, checked by arcium program
    pub comp_def_account: UncheckedAccount<'info>,
    
    pub arcium_program: Program<'info, Arcium>,
    pub system_program: Program<'info, System>,
}
